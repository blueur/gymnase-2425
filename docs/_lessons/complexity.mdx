## Objectifs

Comment comparer des algorithmes ?

- Différencier complexité en temps et en espace
- Estimer la complexité d'un algorithme

## Cours

{props.slides}

## Exercices

Calculer la complexité temporelle et spatiale des algorithmes suivants pour le pire et le meilleur cas :

| &nbsp;       | Temps | Espace |
| ------------ | :---: | :----: |
| Pire cas     |       |        |
| Meilleur cas |       |        |

Commencer par trouver les complexités temporelle et spatiale de quelques cas au hasard, puis chercher à généraliser pour les cas extrêmes.

### Max

```
FONCTION max(a, b)
  SI a < b ALORS
    RETOURNER b
  SINON
    RETOURNER a
  FIN SI
FIN FONCTION
```

<details>
<summary>Solution</summary>

| &nbsp;       |                     Temps                     |       Espace        |
| ------------ | :-------------------------------------------: | :-----------------: |
| Pire cas     |             O(1) : pas de boucle              | O(1) : pas de liste |
| Meilleur cas | O(1) : on ne peut pas faire mieux que contant | O(1) : pas de liste |

</details>

### Max Liste

```
FONCTION max_liste(liste)
  max ← liste[0]
  POUR i DE 1 À liste.taille - 1 FAIRE
    SI liste[i] > max ALORS
      max ← liste[i]
    FIN SI
  FIN POUR
  RETOURNER max
FIN FONCTION
```

<details>
<summary>Solution</summary>

| &nbsp;       |                         Temps                          |         Espace          |
| ------------ | :----------------------------------------------------: | :---------------------: |
| Pire cas     |             O(n) : on parcourt une boucle              | O(n) : il y a une liste |
| Meilleur cas | O(n) : on doit de toute façon parcourir toute la liste | O(n) : il y a une liste |

</details>

### Recherche

```
FONCTION recherche(liste, valeur)
  i ← 0
  TANT QUE i < liste.taille FAIRE
    SI liste[i] = valeur ALORS
      RETOURNER i
    FIN SI
    i ← i + 1
  FIN TANT QUE
  RETOURNER -1
FIN FONCTION
```

<details>
<summary>Solution</summary>

| &nbsp;       |                     Temps                     |         Espace          |
| ------------ | :-------------------------------------------: | :---------------------: |
| Pire cas     | O(n) : l'élément cherché se trouve en dernier | O(n) : il y a une liste |
| Meilleur cas | O(1) : l'élément cherché se trouve en premier | O(n) : il y a une liste |

</details>

### Inverse

```
FONCTION inverse(liste)
  liste_inverse ← liste
  POUR i DE 0 À liste.taille / 2 FAIRE
    liste_inverse[i] ← liste[liste.taille - i - 1]
  FIN POUR
  RETOURNER liste_inverse
FIN FONCTION
```

<details>
<summary>Solution</summary>

| &nbsp;       |               Temps                |         Espace          |
| ------------ | :--------------------------------: | :---------------------: |
| Pire cas     |   O(n) : on parcourt une boucle    | O(n) : il y a une liste |
| Meilleur cas | O(n) : on doit parcourir la boucle | O(n) : il y a une liste |

</details>

## Références

- https://apprendre.modulo-info.ch/algo2/principes.html#principe-de-complexite
- https://fr.wikipedia.org/wiki/Analyse_de_la_complexit%C3%A9_des_algorithmes
- https://fr.wikipedia.org/wiki/Complexit%C3%A9_en_temps
- https://fr.wikipedia.org/wiki/Complexit%C3%A9_en_espace
